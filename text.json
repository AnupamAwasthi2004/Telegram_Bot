{
    "list": "Many algorithms available \n* linearSearch    /linearSearch\n* binarySearch    /binarySearch\n* bubbleSort    /bubbleSort\n* radixSort    /radixSort\n* mergeSort    /mergeSort\n* insertionSort    /insertionSort\n* selectionSort    /selectionSort\n* quickSort    /quickSort",
    "linearSearch": "int search(int arr[], int n, int x) {\n    int i;\n    for (i = 0; i < n; i++) {\n        if (arr[i] == x)\n            return i;\n    }\n    return -1;\n}",
    "binarySearch": "int binarySearch(int arr[], int low, int high, int x) {\n    if (high >= low) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, low, mid - 1, x);\n        return binarySearch(arr, mid + 1, high, x);\n    }\n\n\n    return -1;\n}",
    "bubbleSort": "void bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}",
    "radixSort": "int getMax(int arr[], int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}\n\nvoid countSort(int arr[], int n, int exp) {\n    int output[n];\n    int i, count[10] = {0};\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    int m = getMax(arr, n);\n    for (int exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}",
    "mergeSort": "void merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}",
    "insertionSort": "void insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}",
    "selectionSort": "void selectionSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < n; j++)\n            if (arr[j] < arr[minIdx])\n                minIdx = j;\n        int temp = arr[minIdx];\n        arr[minIdx] = arr[i];\n        arr[i] = temp;\n    }\n}",
    "quickSort": "void quickSort(vector<int>& arr, int left, int right) {\n    if (left < right) {\n        // Pivot selection (using the last element as the pivot)\n        int pivot = arr[right];\n        int i = left - 1;\n\n        // Partitioning the array\n        for (int j = left; j < right; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                std::swap(arr[i], arr[j]);\n            }\n        }\n        std::swap(arr[i + 1], arr[right]);\n\n        int partitionIndex = i + 1;\n\n        // Recursively sort elements before and after partition\n        quickSort(arr, left, partitionIndex - 1);\n        quickSort(arr, partitionIndex + 1, right);\n    }\n}"
}